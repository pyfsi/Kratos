{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Guide to the documentation This website is a collection of all MarkDown (MD) files found in the CoSimulationApplication folder and its subfolders. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file. Documentation in MarkDown MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). Some important rules for writing MD files for this documentation website: The name of the file must be unique: use names like fluent.md or test_examples.md , not readme.md . Links to other MD files: I have yet to test this... probably only works on website, not on GitHub because paths change. Possible fix: automatically replace all names example.md with a proper link. A note on math in MD. There is no out-of-the-box LaTeX compatibiliy sadly, but basic equations can be typeset directly in HTML if necessary. Some usefull symbols: lowercase Greek: \u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03d1\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03d5\u03c7\u03c8\u03c9 uppercase Greek: \u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9 super and subscripts: <sup></sup> and <sub></sub> operators: + - \u2212 \u00b7 / \u00d7 \u221a \u2218 \u2217 other symbols: \u2202 \u0394 \u2211 \u2264 \u2265 \u2208 more math symbols: here and here It is also possible to render LaTeX equations on-the-run and importing them as images, but that is quite cumbersome. Creating a static website with MkDocs MkDocs can be installed using pip: pip install mkdocs Furthermore, the Material theme must be installed: pip install mkdocs-material Both can be installed locally by adding the argument -t <install_dir> . The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in the CoSimulationApplication folder and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . Deploy website on GitHub Pages using mkdocs gh-deploy . Currently, the last step is skipped and the website is deployed (with GitHub Pages) at toondm.github.io/ .","title":"Guide to the documentation"},{"location":"#guide-to-the-documentation","text":"This website is a collection of all MarkDown (MD) files found in the CoSimulationApplication folder and its subfolders. These files are converted to a static website using MkDocs , based on the outline defined in the mkdocs.yml file.","title":"Guide to the documentation"},{"location":"#documentation-in-markdown","text":"MD files are easy to write and read in raw form, and can easily be converted to HTML for nicer rendering. It is easy to learn, see e.g. this tutorial . Several flavors of MD exist, which differ only in some details. GitHub has its own GitHub Flavored Markdown (GFM) , which is used to render MD documents found in repositories on the run. PyCharm comes with an automatic rendering tool built in, and I assume many other IDE's too. The MD documents for the CoCoNuT documentation must be written in the Python-Markdown flavor, because they are processed by MkDocs . This flavor stays very close to the reference implementation of MD. Pay attention to lists: they should be indented with 4 spaces (contrary to GFM). Some important rules for writing MD files for this documentation website: The name of the file must be unique: use names like fluent.md or test_examples.md , not readme.md . Links to other MD files: I have yet to test this... probably only works on website, not on GitHub because paths change. Possible fix: automatically replace all names example.md with a proper link. A note on math in MD. There is no out-of-the-box LaTeX compatibiliy sadly, but basic equations can be typeset directly in HTML if necessary. Some usefull symbols: lowercase Greek: \u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03d1\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c3\u03c4\u03c5\u03c6\u03d5\u03c7\u03c8\u03c9 uppercase Greek: \u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039a\u039b\u039c\u039d\u039e\u039f\u03a0\u03a1\u03a3\u03a4\u03a5\u03a6\u03a7\u03a8\u03a9 super and subscripts: <sup></sup> and <sub></sub> operators: + - \u2212 \u00b7 / \u00d7 \u221a \u2218 \u2217 other symbols: \u2202 \u0394 \u2211 \u2264 \u2265 \u2208 more math symbols: here and here It is also possible to render LaTeX equations on-the-run and importing them as images, but that is quite cumbersome.","title":"Documentation in MarkDown"},{"location":"#creating-a-static-website-with-mkdocs","text":"MkDocs can be installed using pip: pip install mkdocs Furthermore, the Material theme must be installed: pip install mkdocs-material Both can be installed locally by adding the argument -t <install_dir> . The structure/outline of the website is dictated by the nav variable in mkdocs.yml . This is the only variable that must be adjusted when new MD files are added to the code. The complete process to create the documentation website is automated by run_mkdocs.py . This does the following things: Copy all MD files in the CoSimulationApplication folder and its subfolders to folder docs . Check if there are duplicate filenames: these overwrite each other! If duplicates are found, a warning is given with the original paths. Check if each MD file is mentioned in mkdocs.yml . If a file is not mentioned, a warning is given. Build static HTML website using mkdocs build . Deploy website on GitHub Pages using mkdocs gh-deploy . Currently, the last step is skipped and the website is deployed (with GitHub Pages) at toondm.github.io/ .","title":"Creating a static website with MkDocs"},{"location":"fluent/","text":"SolverWrapperFluent This is the documentation for all Fluent SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Also, inviscid flows are not supported yet. Parameters This section describes the Parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder working_directory . cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher CoSimulationObject. flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. hybrid_initialization bool If true , the hybrid initialization is used in Fluent before the first timestep. If false , the standard initialization is used, which requires that adequate reference values have been set in advance by the user in the case_file . interface_input dict Keys are names of ModelParts for Fluent nodes. Each name must be the concatenation of an entry from thread_names and '_nodes'. The values are (lists of) names of Variables. interface_output dict Analogous to interface_input , but for Fluent faces ('_faces'). max_nodes_per_face int The parameter is used to construct unique IDs for faces, based on unique IDs of nodes. It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces. save_iterations int Number of timesteps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the interface. IS THE ORDER IMPORTANT? TODO timestep_start int Timestep number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher CoSimulationObject. unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher CoSimulationObject. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section. Overview of operation The solver wrapper consists of 3 files (with X the Fluent version, e.g. 2019R1): - X.py: defines the SolverWrapperFluentX class - X.jou: Fluent journal file to interactively run the FSI simulation, written in Scheme - X.c: Fluent UDF file that implements additional functionality used in Fluent, written in C The __init__ method During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summery, so that SolverWrapperFluentX can link the interface thread names (specified in thread_names ) to thread IDs, for use in the UDFs. Then the Model and ModelPart objects are created, based on data written by Fluent in timestep 0. After a restart, this same data must be found, i.e. if that file is removed from the working_directory , the simulation cannot be restarted. If the simulation was restarted, the coordinates X , Y , Z in the Node objects are updated to the current values. Finally, the CoSimulationInteface objects are made. Files created during simulation In the file conventions, A is the timestep number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to Python with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from Python to Fluent with files of the form nodes_update_timestepA_threadB . Pressure and tractions are passed from Fluent to Python with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to pass messages between Python and Fluent (via the journal). Setting up a new case Following items should be set up and saved in the case_file (this list may be non-exhaustive): additional UDFs must be configured steady/unsteady (should match with the unsteady parameter) 2D, 3D or axisymmetric (should match with the dimensions parameter) dynamic mesh for all zones, except the FSI interfaces boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria if hybrid_initialization is false , then default should be set for standard initialization Following items are done after starting the FSI simulation, and must therefore not be included in the case_file : dynamic mesh for the FSI interfaces (which are defined in thread_names ) the timestep ( delta_t ) initialization Version specific documentation 2019R1 (19.3) This is currently the only version, so this section is still empty.","title":"SolverWrapperFluent"},{"location":"fluent/#solverwrapperfluent","text":"This is the documentation for all Fluent SolverWrappers. Currently only FSI simulations are supported, no other multiphysics problems. Also, inviscid flows are not supported yet.","title":"SolverWrapperFluent"},{"location":"fluent/#parameters","text":"This section describes the Parameters in the JSON file, listed in alphabetical order. parameter type description case_file string Name of the case file. It must be present in the folder working_directory . cores int Number of processor cores to use when running Fluent (tested only on single node so far). dimensions int Dimension used in flow solver: 2 for 2D and axisymmetric, 3 for 3D. delta_t double Fixed timestep size in flow solver. This parameter is usually specified in a higher CoSimulationObject. flow_iterations int Number of non-linear iterations in Fluent per coupling iteration. fluent_gui bool Set to true to run Fluent with the graphical interface. hybrid_initialization bool If true , the hybrid initialization is used in Fluent before the first timestep. If false , the standard initialization is used, which requires that adequate reference values have been set in advance by the user in the case_file . interface_input dict Keys are names of ModelParts for Fluent nodes. Each name must be the concatenation of an entry from thread_names and '_nodes'. The values are (lists of) names of Variables. interface_output dict Analogous to interface_input , but for Fluent faces ('_faces'). max_nodes_per_face int The parameter is used to construct unique IDs for faces, based on unique IDs of nodes. It should be at least as high as the maximum number of nodes on a face on the interface. Use e.g. 4 for rectangular faces, 3 for triangular faces. save_iterations int Number of timesteps between consecutive saves of the Fluent case and data files. thread_names list List with Fluent names of the surface threads on the interface. IS THE ORDER IMPORTANT? TODO timestep_start int Timestep number to (re)start a transient FSI calculation. If 0 is given, the simulation starts from the case_file , else the code looks for the relevant case and data files. This parameter is usually specified in a higher CoSimulationObject. unsteady bool true for transient FSI, false for steady FSI. working_directory string Absolute path to the working directory or relative path w.r.t the current directory. timestep_start and delta_t are necessary parameters, but are usually defined in a higher CoSimulationObject. However, they can also be given directly as parameter of the solver wrapper (e.g. for standalone testing). If they are defined both in higher object and in the solver wrapper, then the former value is used and a warning is printed. If different parameters are used with different Fluent versions, this should be specified both in this section and in the version specific documentation section.","title":"Parameters"},{"location":"fluent/#overview-of-operation","text":"The solver wrapper consists of 3 files (with X the Fluent version, e.g. 2019R1): - X.py: defines the SolverWrapperFluentX class - X.jou: Fluent journal file to interactively run the FSI simulation, written in Scheme - X.c: Fluent UDF file that implements additional functionality used in Fluent, written in C","title":"Overview of operation"},{"location":"fluent/#the-__init__-method","text":"During initialization, the journal and UDF files are adapted (parameter values are filled in) and copied to the working_directory . Fluent is then started in that directory using the parameters cores , dimensions and fluent_gui . Fluent then writes a case summery, so that SolverWrapperFluentX can link the interface thread names (specified in thread_names ) to thread IDs, for use in the UDFs. Then the Model and ModelPart objects are created, based on data written by Fluent in timestep 0. After a restart, this same data must be found, i.e. if that file is removed from the working_directory , the simulation cannot be restarted. If the simulation was restarted, the coordinates X , Y , Z in the Node objects are updated to the current values. Finally, the CoSimulationInteface objects are made.","title":"The __init__ method"},{"location":"fluent/#files-created-during-simulation","text":"In the file conventions, A is the timestep number and B the Fluent thread ID. Fluent case and data files are saved as files of the form case_timestepA.cas and case_timestepA.dat . Current node and face coordinates are passed from Fluent to Python with files of the form nodes_timestepA_threadB.dat and faces_timestepA_threadB.dat . The new node coordinates are passed from Python to Fluent with files of the form nodes_update_timestepA_threadB . Pressure and tractions are passed from Fluent to Python with files of the form pressure_traction_timestepA_threadB.dat . Files with extension .coco are used to pass messages between Python and Fluent (via the journal).","title":"Files created during simulation"},{"location":"fluent/#setting-up-a-new-case","text":"Following items should be set up and saved in the case_file (this list may be non-exhaustive): additional UDFs must be configured steady/unsteady (should match with the unsteady parameter) 2D, 3D or axisymmetric (should match with the dimensions parameter) dynamic mesh for all zones, except the FSI interfaces boundary conditions, material properties, numerical models, discretization schemes, operating conditions, turbulence modeling, convergence criteria if hybrid_initialization is false , then default should be set for standard initialization Following items are done after starting the FSI simulation, and must therefore not be included in the case_file : dynamic mesh for the FSI interfaces (which are defined in thread_names ) the timestep ( delta_t ) initialization","title":"Setting up a new case"},{"location":"fluent/#version-specific-documentation","text":"","title":"Version specific documentation"},{"location":"fluent/#2019r1-193","text":"This is currently the only version, so this section is still empty.","title":"2019R1 (19.3)"},{"location":"mappers/","text":"Mappers General concepts Hierarchy of mapping-related objects CoCoNuT interacts with the mappers through the SolverWrapperMapped object: this wrapper behaves like every other SolverWrapper as far as the other components are concerned. It contains 3 main components: a Mapper for the input, a real SolverWrapper and a Mapper for the output. The mappers are initialized through the SetInterfaceInput and SetInterfaceOutput methods respectively, by providing them with the CoSimulationInterface objects that will be respectively the input and output of the SolverWrapperMapped object. The two mappers in the SolverWrapperMapped object are also of a special type: they work on the level of CoSimulationInterface objects. They are some sort of mapper-wrapper around the actual mappers which work on ModelPart level. Currently only one such mapper is available, aptly called MapperInterface . At the lowest level, mappers interpolate historical variables between two ModelPart objects, based on the coordinates of the nodes. Interpolation is always done from the from - ModelPart to the to - ModelPart . These mappers can be chained together in a MapperCombined object, creating in fact another layer of mapping. So many layers! Like an onion! Interpolators and transformers The ModelPart -level mappers have two main methods: Initialize and __call__ . The Initialize method performs one-time expensive operations, namely nearest-neighbour search and calculation of the interpolation coefficients. The initialization is done based on the original coordinates X0 , Y0 and Z0 . The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively), each tuple containing the ModelPart and the Variable to be used in the interpolation. This method returns nothing: the interpolation is done in-place in the ModelPart objects. There are two types of ModelPart -level mappers: interpolators and transformers. They can be distinguished by their boolean interpolator attribute (see __init__ ). For interpolators, Initialize gets two ModelPart objects ( from and to ), and returns nothing. These mappers do the real interpolation. Currently MapperNearest , MapperLinear and MapperRadialBasis are available. For transformers, Initialize gets only one ModelPart (from either the from or to side, depending on the transformation), and returns the other ModelPart . Currently MapperPermutation , MapperAxisymmetric2DTo3D and MapperAxisymmetric3DTo2D are available. A transformer can never be used by itself, it must always be combined with an interpolator: the reason is that interpolators use information coming from two sides, which is exactly what the SolverWrapperMapped and MapperInterface objects want. To chain together multiple mappers, the MapperCombined is used: it contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. Overview of special mappers MapperInterface Special mapper-class that maps on the level of CoSimulationInterface objects. It takes two CoSimulationInterface objects, and maps the ModelPart objects to each other in order of appearance, all using the same ModelPart mapper. To use different interpolation for the different ModelPart objects or even for different historical variables, a new CoSimulationInterface mapper must be written. JSON setting type description type str ModelPart mapper to be used settings dict all the settings for the ModelPart mapper specified in type MapperCombined The MapperCombined is used to chain together multiple mappers. It contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. If transformers are present, intermediate ModelPart objects are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from ModelPart (input), while downstream transformers are initialized based on the to ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to ModelPart must be supplied, therefore it must be downstream of the interpolator. JSON setting type description mappers list an ordered list of all the ModelPart mappers to be used Overview of transformers MapperPermutation Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list a permutation of the list [0, 1, 2] MapperAxisymmetric2DTo3D Transforms from a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in a MapperCombined . The 3D ModelPart is returned by the initialization. n_tangential specifies the number of Node objects in the tangential (circumferential) direction. For each Node in the 2D ModelPart , n_tangential ones are created in the 3D ModelPart . The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added for that purpose. Scalar variables are simply mapped from the 2D Node to all corresponding 3D ones. For vector variables, the axial component is simply mapped, the radial component is rotated. The tangential component (e.g. swirl) cannot be taken into account. JSON setting type description direction_axial string must be \"X\" , \"Y\" or \"Z\" , specifies the symmetry axis direction_radial string must be \"X\" , \"Y\" or \"Z\" , specifies the second (radial) axis in 2D n_tangential int must be \u2265 6 MapperAxisymmetric3DTo2D Transforms from a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the MapperInterpolator in a MapperCombined . For scalar variables, the circumferential average is taken for each 2D Node . For vector variables too, taking into account the correct radial direction in each 3D Node . Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not mapped to 2D. For more information and JSON settings, see MapperAxisymmetric2DTo3D which is very similar. Overview of interpolators MapperInterpolator Base-class for all interpolators (currently MapperNearest , MapperLinear and MapperRadialBasis ). JSON setting type description directions list list of coordinate directions, maximum three entries, may contain \"X\" , \"Y\" , \"Z\" balanced_tree bool if true , create balanced cKDTree , which is more stable, but takes longer to build; set to true if the tree is giving problems (which I don't expect) The Initialize -method should be called in all child-classes. It does the following: - read and store the coordinates from the from and to ModelPart objects - check if the bounding boxes of the from and to ModelPart objects are more or less overlapping - do an efficient nearest neighbour search using scipy.spatial.cKDTree - check if the from ModelPart does not contain duplicate nodes (i.e. same coordinates) The __call__ -method should not be overridden in the child-classes. It maps historical variables based on neighbours and coefficients determined in Initialize . Historical variables of type Double and type Array can be mapped (the latter is just the application of the former for each vector component). MapperNearest Child-class of MapperInterpolator , does not require additional settings. Does simple nearest-neighbour mapping. MapperLinear Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D - If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D - The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D - The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consinsting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed. MapperRadialBasis Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \u03c6 ( r ) is a radial basis function defined as \u03c6 ( r ) = (1 \u2212 r ) 4 (1 + 4 r ) for 0 \u2264 r < 1 \u03c6 ( r ) = 0 for 1 \u2264 r with r a positive distance. Assume that n nearest from -points will be used in the interpolation. An unknown function f ( x ) can then be approximated as the weighted sum of n shifted radial basis functions: f ( x ) \u2248 \u03a3 j \u03b1 j \u03c6 (|| x \u2212 x j ||) To determine the coefficients \u03b1 j , we require that the exact function value is returned at the n from -points. This gives us n equations f ( x i ) = f i = \u03a3 j \u03b1 j \u03c6 (|| x i \u2212 x j ||) which can be written in matrix form as f = \u03a6 \u00b7 \u03b1 with f , \u03b1 \u2208 R n\u00d71 , and \u03a6 \u2208 R n\u00d7n . This system can be solved for the weights-vector \u03b1 . However, in our case, the from -point values vector f is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f ( x to ) = \u03a3 j \u03b1 j \u03c6 (|| x to \u2212 x j ||) = \u03a6 T to \u00b7 \u03b1 = \u03a6 T to \u00b7 \u03a6 -1 \u00b7 f = c T \u00b7 f The coefficients vector c can now be calculated based only on the coordinates by solving the system \u03a6 \u00b7 c = \u03a6 to . As every to-point has different nearest neighbours in the from -points, the coefficient vector c must be calculated for each to -point independently. The matrix \u03a6 and vector \u03a6 T must also be calculated for every to -point independently.","title":"Mappers"},{"location":"mappers/#mappers","text":"","title":"Mappers"},{"location":"mappers/#general-concepts","text":"","title":"General concepts"},{"location":"mappers/#hierarchy-of-mapping-related-objects","text":"CoCoNuT interacts with the mappers through the SolverWrapperMapped object: this wrapper behaves like every other SolverWrapper as far as the other components are concerned. It contains 3 main components: a Mapper for the input, a real SolverWrapper and a Mapper for the output. The mappers are initialized through the SetInterfaceInput and SetInterfaceOutput methods respectively, by providing them with the CoSimulationInterface objects that will be respectively the input and output of the SolverWrapperMapped object. The two mappers in the SolverWrapperMapped object are also of a special type: they work on the level of CoSimulationInterface objects. They are some sort of mapper-wrapper around the actual mappers which work on ModelPart level. Currently only one such mapper is available, aptly called MapperInterface . At the lowest level, mappers interpolate historical variables between two ModelPart objects, based on the coordinates of the nodes. Interpolation is always done from the from - ModelPart to the to - ModelPart . These mappers can be chained together in a MapperCombined object, creating in fact another layer of mapping. So many layers! Like an onion!","title":"Hierarchy of mapping-related objects"},{"location":"mappers/#interpolators-and-transformers","text":"The ModelPart -level mappers have two main methods: Initialize and __call__ . The Initialize method performs one-time expensive operations, namely nearest-neighbour search and calculation of the interpolation coefficients. The initialization is done based on the original coordinates X0 , Y0 and Z0 . The __call__ method is used for the actual mapping. It takes two tuples as arguments ( from and to respectively), each tuple containing the ModelPart and the Variable to be used in the interpolation. This method returns nothing: the interpolation is done in-place in the ModelPart objects. There are two types of ModelPart -level mappers: interpolators and transformers. They can be distinguished by their boolean interpolator attribute (see __init__ ). For interpolators, Initialize gets two ModelPart objects ( from and to ), and returns nothing. These mappers do the real interpolation. Currently MapperNearest , MapperLinear and MapperRadialBasis are available. For transformers, Initialize gets only one ModelPart (from either the from or to side, depending on the transformation), and returns the other ModelPart . Currently MapperPermutation , MapperAxisymmetric2DTo3D and MapperAxisymmetric3DTo2D are available. A transformer can never be used by itself, it must always be combined with an interpolator: the reason is that interpolators use information coming from two sides, which is exactly what the SolverWrapperMapped and MapperInterface objects want. To chain together multiple mappers, the MapperCombined is used: it contains always 1 interpolator and 0 or more transformers, on either side of the interpolator.","title":"Interpolators and transformers"},{"location":"mappers/#overview-of-special-mappers","text":"","title":"Overview of special mappers"},{"location":"mappers/#mapperinterface","text":"Special mapper-class that maps on the level of CoSimulationInterface objects. It takes two CoSimulationInterface objects, and maps the ModelPart objects to each other in order of appearance, all using the same ModelPart mapper. To use different interpolation for the different ModelPart objects or even for different historical variables, a new CoSimulationInterface mapper must be written. JSON setting type description type str ModelPart mapper to be used settings dict all the settings for the ModelPart mapper specified in type","title":"MapperInterface"},{"location":"mappers/#mappercombined","text":"The MapperCombined is used to chain together multiple mappers. It contains always 1 interpolator and 0 or more transformers, on either side of the interpolator. If transformers are present, intermediate ModelPart objects are created during initialization. This is done by working inwards towards the interpolator. This means that transformers upstream of the interpolator, are initialized based on the from ModelPart (input), while downstream transformers are initialized based on the to ModelPart (output). Some transformers can only be initialized in one direction, e.g. for MapperAxisymmetric3DTo2D , the 2D to ModelPart must be supplied, therefore it must be downstream of the interpolator. JSON setting type description mappers list an ordered list of all the ModelPart mappers to be used","title":"MapperCombined"},{"location":"mappers/#overview-of-transformers","text":"","title":"Overview of transformers"},{"location":"mappers/#mapperpermutation","text":"Permutates the coordinates and the vector variables according to the given permutation . This transformer can be initialized in both directions. JSON setting type description permutation list a permutation of the list [0, 1, 2]","title":"MapperPermutation"},{"location":"mappers/#mapperaxisymmetric2dto3d","text":"Transforms from a 2D axisymmetric geometry to a 3D geometry. This transformer can only be initialized in the forward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be upstream of the interpolator in a MapperCombined . The 3D ModelPart is returned by the initialization. n_tangential specifies the number of Node objects in the tangential (circumferential) direction. For each Node in the 2D ModelPart , n_tangential ones are created in the 3D ModelPart . The code knows which directions are axial, radial and tangential thanks to the input parameters direction_axial and direction_radial . It is not possible to change the axial direction between 2D and 3D: a separate MapperPermutation should be added for that purpose. Scalar variables are simply mapped from the 2D Node to all corresponding 3D ones. For vector variables, the axial component is simply mapped, the radial component is rotated. The tangential component (e.g. swirl) cannot be taken into account. JSON setting type description direction_axial string must be \"X\" , \"Y\" or \"Z\" , specifies the symmetry axis direction_radial string must be \"X\" , \"Y\" or \"Z\" , specifies the second (radial) axis in 2D n_tangential int must be \u2265 6","title":"MapperAxisymmetric2DTo3D"},{"location":"mappers/#mapperaxisymmetric3dto2d","text":"Transforms from a 3D geometry to a 2D axisymmetric geometry. This transformer can only be initialized in the backward direction, i.e. based on the 2D axisymmetric ModelPart . Therefore, it should be downstream of the MapperInterpolator in a MapperCombined . For scalar variables, the circumferential average is taken for each 2D Node . For vector variables too, taking into account the correct radial direction in each 3D Node . Again, swirl cannot be taken into account: if a tangential component is present in 3D, it is not mapped to 2D. For more information and JSON settings, see MapperAxisymmetric2DTo3D which is very similar.","title":"MapperAxisymmetric3DTo2D"},{"location":"mappers/#overview-of-interpolators","text":"","title":"Overview of interpolators"},{"location":"mappers/#mapperinterpolator","text":"Base-class for all interpolators (currently MapperNearest , MapperLinear and MapperRadialBasis ). JSON setting type description directions list list of coordinate directions, maximum three entries, may contain \"X\" , \"Y\" , \"Z\" balanced_tree bool if true , create balanced cKDTree , which is more stable, but takes longer to build; set to true if the tree is giving problems (which I don't expect) The Initialize -method should be called in all child-classes. It does the following: - read and store the coordinates from the from and to ModelPart objects - check if the bounding boxes of the from and to ModelPart objects are more or less overlapping - do an efficient nearest neighbour search using scipy.spatial.cKDTree - check if the from ModelPart does not contain duplicate nodes (i.e. same coordinates) The __call__ -method should not be overridden in the child-classes. It maps historical variables based on neighbours and coefficients determined in Initialize . Historical variables of type Double and type Array can be mapped (the latter is just the application of the former for each vector component).","title":"MapperInterpolator"},{"location":"mappers/#mappernearest","text":"Child-class of MapperInterpolator , does not require additional settings. Does simple nearest-neighbour mapping.","title":"MapperNearest"},{"location":"mappers/#mapperlinear","text":"Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients The kind of linear mapping depends on the number of coordinate directions, as given in the directions setting. 1D - If the to -point lies between the 2 nearest from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 2D - The to -point is first projected on the line through the 2 nearest from -points. If the projected point lies between the from -points, linear interpolation is done. Else, nearest neighbour interpolation is done. 3D - The to -point is first projected on the plane through the 3 nearest from -points. If the triangle consinsting of those 3 points is deprecated (colinear points), the 2D-methodology is followed. Else, if the projected point lies inside the triangle, barycentric interpolation is done. If it lies outside the triangle, the 2D-methodology is followed.","title":"MapperLinear"},{"location":"mappers/#mapperradialbasis","text":"Child-class of MapperInterpolator , additional settings: JSON setting type description parallel bool if true , use multiprocessing to parallellize loop that calculates coefficients Radial basis function interpolation is relatively straightforward: implementation for 1D, 2D and 3D is exactly the same and can be written in a condensed way using scipy.spatial.distance . Normal radial basis interpolation is done as follows. \u03c6 ( r ) is a radial basis function defined as \u03c6 ( r ) = (1 \u2212 r ) 4 (1 + 4 r ) for 0 \u2264 r < 1 \u03c6 ( r ) = 0 for 1 \u2264 r with r a positive distance. Assume that n nearest from -points will be used in the interpolation. An unknown function f ( x ) can then be approximated as the weighted sum of n shifted radial basis functions: f ( x ) \u2248 \u03a3 j \u03b1 j \u03c6 (|| x \u2212 x j ||) To determine the coefficients \u03b1 j , we require that the exact function value is returned at the n from -points. This gives us n equations f ( x i ) = f i = \u03a3 j \u03b1 j \u03c6 (|| x i \u2212 x j ||) which can be written in matrix form as f = \u03a6 \u00b7 \u03b1 with f , \u03b1 \u2208 R n\u00d71 , and \u03a6 \u2208 R n\u00d7n . This system can be solved for the weights-vector \u03b1 . However, in our case, the from -point values vector f is not known in advance: it contains the values of the Variable that will be interpolated. Therefore, the approximation to calculate the interpolatoin in the to -point is rewritten as follows: f ( x to ) = \u03a3 j \u03b1 j \u03c6 (|| x to \u2212 x j ||) = \u03a6 T to \u00b7 \u03b1 = \u03a6 T to \u00b7 \u03a6 -1 \u00b7 f = c T \u00b7 f The coefficients vector c can now be calculated based only on the coordinates by solving the system \u03a6 \u00b7 c = \u03a6 to . As every to-point has different nearest neighbours in the from -points, the coefficient vector c must be calculated for each to -point independently. The matrix \u03a6 and vector \u03a6 T must also be calculated for every to -point independently.","title":"MapperRadialBasis"},{"location":"pykratos/","text":"CoSimulation Application PYTHON ONLY VERSION This is the description for the python-only version of the CoSimulationApplication. Kratos is only used as a container for data within the CoSimulationApplication, the CoSimApp itself is coded in python. For the python-only version, Kratos is replaced by pyKratos, which is a python version of Kratos which implements the basic features (of KratosMultiphysics) required for CoSimulation. The version of pyKratos within this folder is based on the work of Riccardo Rossi In order to install the python-version, please follow the instructions in configure_py_co_sim.sh . For this no compilation is required. The tests can be executed by running python test_CoSimulationApplication.py in the folder tests","title":"Pykratos"},{"location":"pykratos/#cosimulation-application-python-only-version","text":"This is the description for the python-only version of the CoSimulationApplication. Kratos is only used as a container for data within the CoSimulationApplication, the CoSimApp itself is coded in python. For the python-only version, Kratos is replaced by pyKratos, which is a python version of Kratos which implements the basic features (of KratosMultiphysics) required for CoSimulation. The version of pyKratos within this folder is based on the work of Riccardo Rossi In order to install the python-version, please follow the instructions in configure_py_co_sim.sh . For this no compilation is required. The tests can be executed by running python test_CoSimulationApplication.py in the folder tests","title":"CoSimulation Application PYTHON ONLY VERSION"},{"location":"python_solvers/","text":"Pure Python SolverWrappers (empty documentation)","title":"Pure Python SolverWrappers"},{"location":"python_solvers/#pure-python-solverwrappers","text":"(empty documentation)","title":"Pure Python SolverWrappers"},{"location":"test_examples/","text":"Test Examples This documentation describes the different test examples. Currently all these examples calculate the flow in a flexible tube. Folder and file structure This section describes the different folders and files which are provided. MainKratos.py: Main file which has to be run with a parameterfile as argument project_parameters_X.json: Parameter file in json format setup_X: Setup folder containing all files for setting up solver X setup_X.sh: Bash file which has to be run to set up solver X readme.md: A description of the specific example When the setup files are run, working directories are created which have to match the ones specified in the parameter file. These folder are expandalbe and are deleted when the setup files are (re)run. Running a case In order to run a test example, the case have to be made ready by running the setup files for both solvers. Then, the calculation is started by running MainKratos.py with the parameter file as argument. Debug files The folder test_examples also contains a folder debug_files with files for debug purposes. In order to use those, the debug boolean self.debug has to be True in the corresponding solver wrappers.","title":"Test Examples"},{"location":"test_examples/#test-examples","text":"This documentation describes the different test examples. Currently all these examples calculate the flow in a flexible tube.","title":"Test Examples"},{"location":"test_examples/#folder-and-file-structure","text":"This section describes the different folders and files which are provided. MainKratos.py: Main file which has to be run with a parameterfile as argument project_parameters_X.json: Parameter file in json format setup_X: Setup folder containing all files for setting up solver X setup_X.sh: Bash file which has to be run to set up solver X readme.md: A description of the specific example When the setup files are run, working directories are created which have to match the ones specified in the parameter file. These folder are expandalbe and are deleted when the setup files are (re)run.","title":"Folder and file structure"},{"location":"test_examples/#running-a-case","text":"In order to run a test example, the case have to be made ready by running the setup files for both solvers. Then, the calculation is started by running MainKratos.py with the parameter file as argument.","title":"Running a case"},{"location":"test_examples/#debug-files","text":"The folder test_examples also contains a folder debug_files with files for debug purposes. In order to use those, the debug boolean self.debug has to be True in the corresponding solver wrappers.","title":"Debug files"},{"location":"tube_fluent2D_abaqus2D/","text":"Description of tube2D_fluent_abaqus This documentation describes the test example tube2D_fluent_abaqus. Solvers The flow solver is fluent, used to solve an axisymmetric representation of a tube. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is abaqus, used to solve an axisymmetric representation of a tube. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Fluent 2D - Abaqus 2D"},{"location":"tube_fluent2D_abaqus2D/#description-of-tube2d_fluent_abaqus","text":"This documentation describes the test example tube2D_fluent_abaqus.","title":"Description of tube2D_fluent_abaqus"},{"location":"tube_fluent2D_abaqus2D/#solvers","text":"The flow solver is fluent, used to solve an axisymmetric representation of a tube. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is abaqus, used to solve an axisymmetric representation of a tube. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Solvers"},{"location":"tube_fluent2D_tube_structure/","text":"Description of fluent_pipe_structure This documentation describes the test example fluent_pipe_structure. Solvers The flow solver is fluent, used to solve an axisymmetric representation of a tube. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is the 2D pipe_structure_inert solver. The axial direction is along the Z-axis, the radial direction along the Y-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Fluent 2D - Python"},{"location":"tube_fluent2D_tube_structure/#description-of-fluent_pipe_structure","text":"This documentation describes the test example fluent_pipe_structure.","title":"Description of fluent_pipe_structure"},{"location":"tube_fluent2D_tube_structure/#solvers","text":"The flow solver is fluent, used to solve an axisymmetric representation of a tube. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is the 2D pipe_structure_inert solver. The axial direction is along the Z-axis, the radial direction along the Y-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Solvers"},{"location":"tube_fluent3D_abaqus3D/","text":"Description of tube3D_fluent_abaqus This documentation describes the test example tube3D_fluent_abaqus. Solvers The flow solver is fluent. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is abaqus. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Fluent 3D - Abaqus 3D"},{"location":"tube_fluent3D_abaqus3D/#description-of-tube3d_fluent_abaqus","text":"This documentation describes the test example tube3D_fluent_abaqus.","title":"Description of tube3D_fluent_abaqus"},{"location":"tube_fluent3D_abaqus3D/#solvers","text":"The flow solver is fluent. The axial direction is along the X-axis, the radial direction along the Y-axis. The structure solver is abaqus. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Solvers"},{"location":"tube_tube_flow_abaqus2D/","text":"Description of pipe_flow_abaqus This documentation describes the test example pipe_flow_abaqus. Solvers The flow solver is pipe_flow, a 1D solver which communicates as a 2D solver. The axial direction is along the Z-axis, the radial direction along the Y-axis. The structure solver is abaqus, which solves an axisymmetric case. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Python - Abaqus 2D"},{"location":"tube_tube_flow_abaqus2D/#description-of-pipe_flow_abaqus","text":"This documentation describes the test example pipe_flow_abaqus.","title":"Description of pipe_flow_abaqus"},{"location":"tube_tube_flow_abaqus2D/#solvers","text":"The flow solver is pipe_flow, a 1D solver which communicates as a 2D solver. The axial direction is along the Z-axis, the radial direction along the Y-axis. The structure solver is abaqus, which solves an axisymmetric case. The axial direction is along the Y-axis, the radial direction along the X-axis. A permutation mapper is introduced between the solvers, to match the coordinate frames.","title":"Solvers"},{"location":"tube_tube_flow_tube_structure/","text":"Description of 04_tube This documentation describes the test example 04_tube. Solvers The flow solver is the pipe_flow solver. The structure solver is the pipe_structure solver.","title":"Python - Python"},{"location":"tube_tube_flow_tube_structure/#description-of-04_tube","text":"This documentation describes the test example 04_tube.","title":"Description of 04_tube"},{"location":"tube_tube_flow_tube_structure/#solvers","text":"The flow solver is the pipe_flow solver. The structure solver is the pipe_structure solver.","title":"Solvers"},{"location":"tube_tube_flow_tube_structure_inert/","text":"Description of 04_tube2D This documentation describes the test example 04_tube2D. Solvers The flow solver is the pipe_flow solver. The structure solver is the pipe_structure_inert solver.","title":"Python - Python inert"},{"location":"tube_tube_flow_tube_structure_inert/#description-of-04_tube2d","text":"This documentation describes the test example 04_tube2D.","title":"Description of 04_tube2D"},{"location":"tube_tube_flow_tube_structure_inert/#solvers","text":"The flow solver is the pipe_flow solver. The structure solver is the pipe_structure_inert solver.","title":"Solvers"}]}